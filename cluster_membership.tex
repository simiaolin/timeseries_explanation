\chapter{Explaining cluster membership }
\label{cha:cluster_membership}
Clustering is inherently subjective. We have introduced in \cref{sec:COBRA} that COBRA is a semi-supervised clustering method. It allows users to designate relation between instances to exploit expert knowledge. When presenting the clustering result to them, we should be able to convince them that their designation has been well applied and retained. 

COBRAS is a enhanced variant of CORBA that allows splitting on super-instances after they are formed to get clustering of better-granularity. $\mathrm{COBRAS^{TS}}$ is a time series variant of COBRAS. We are interested in explaining the cluster menbership of time series instances in $\mathrm{COBRAS^{TS}}$ because time series data are easier to visualize than other formats such as attribute-value pairs.

Providing users the properties of clusters is a good way to help them build an overview of the clusters. However, if they are interested in more specific aspects, like why two sequences are clustered together, or why they are seperated from each other, the overall properties can do little. For instance in \cref{fig:mbs_ecg_circled}, looking at the sequences of the largest cluster of ECG dataset with a query budget of 100 in $\mathrm{COBRAS^{TS}}$, people would easily question why the blue sequences are in this cluster. There are obvious higher peaks with values around 3 at index around 92 in the blue sequences. However, there are neither such kind of high peaks in other sequences in the cluster nor in the DBA of this cluster. There is no such peak in the DBA because the number of blue sequences are not comparable to that of the other sequences, so the peak information in hte blue sequences are lost in DBA because DBA is a weighted average. However, why blue sequences are clustered together with other sequences is still a mystery to us. That is the intention we propose in this section the membership of a sequence in one cluster. We mainly illustrates the membership of sequences with the help of must-links and cannot-links. 

\begin{figure}[htbp]	
	\centering
	\includegraphics[width=\linewidth]{pics/membership/ecg_LINKS/cluster0_circled}
	\caption{why these blue sequences are in the same cluster as other sequences?}
	\label{fig:mbs_ecg_circled}
\end{figure}

\subsection{Instances in one cluster}

$\mathrm{COBRAS^{TS}}$ forms clusters mainly based on the constraints provided by users and the similarity between sequences. There are two important stages in it, spilitting stage and merging stage, respectively. $\mathrm{COBRAS^{TS}}$ conducts these two stages alternately.

In the splitting stage, $\mathrm{COBRAS^{TS}}$ find the biggest super-instances that has the largest number of instances and splits it. To split the  super-instance, it first determines the splitting level $\mathit{k}$ and then splits the super-instance to $\mathit{k}$ mini super-instances. $\mathrm{COBRAS^{TS}}$ queries users about constraints between sequences to determine the splitting level. These obtained constraints are stored and could be reused. $\mathrm{COBRAS^{TS}}$ only queries users relation between two sequences when the relation of them could not be found int the stored constraints pool to save the query number as there is a query budget. When the splitting level is determined, it splits the super-instance using Spectural Clustering based on the affinity matrix containing the DTW distances between all the sequences in the super-instance. 

In the merging stage, $\mathrm{COBRAS^{TS}}$ first finds all the cluster pairs that are possible to be merged. A cluster pair ($\mathcal{C}_1, \mathcal{C}_2$) is considered as a merging candidate if there is no cannot-link between super-instance $\mathit{S_1}$ and super-instance $\mathit{S_2}$ as long as $\mathit{S_1}$ is in $ \mathcal{C}_1 $ and $\mathit{S_2}$ is in $ \mathcal{C}_2 $. All the candidate cluster pairs are sorted by their distance and queried one by one. Once a must-link between a candidate cluster pair is obtained, the candidate cluster pair is merged and $\mathrm{COBRAS^{TS}}$ continues to find new candidate cluster pairs, sort by their distances, and do the constraint checks and merging again as long as the query budget is not used up. The merging stage stops when the query budget is used up or there is no more merging candidate cluster pair. Like the determing splitting level stage in the splitting stage, all the obtained must-links and cannot-links are stored  in the constraints pool during the merging stage. 

When querying the relation between a cluster pair ($\mathcal{C}_1, \mathcal{C}_2$), $\mathrm{COBRAS^{TS}}$ actually queries the relation between super-instances $\mathit{S_1}$ and $\mathit{S_2}$ where $\mathit{S_1}$ is in $\mathcal{C}_1$ and $\mathit{S_2}$ is in $\mathcal{C}_2$.
When querying the relation between super-instances $\mathit{S_1}$ and $\mathit{S_2}$, $\mathrm{COBRAS^{TS}}$ actually queries the relation between the representative sequence $\mathit{I_1}$ of super-instance $\mathit{S_1}$ and representative sequence $\mathit{I_2}$ of super-instance $\mathit{S_2}$. The representative sequence $\mathit{I}$ of a super-instance $\mathit{S}$ is the sequence in $\mathit{S}$ which has the smallest sum of distances to all the other sequences in $\mathit{S}$. When we talk about the relation between two super-instances, we are also talk about the relation between the representatives of these two super-instances, vice versa.

For every two super-instances $\mathit{S_1}$, $\mathit{S_2}$ in a cluster, either there is a direct must-link between them, or there are other super-instances $\mathit{S_3}$, $\mathit{S_4}$, ..., $\mathit{S_n}$ where there is a must-link between $\mathit{S_1}$ and $\mathit{S_3}$, a must-link between $\mathit{S_4}$ and $\mathit{S_5}$, ..., a must-link between $\mathit{S_{n-1}}$ and $\mathit{S_n}$, a must-link between $\mathit{S_n}$ and $\mathit{S_2}$. In other words, if there is no direct must-link between two super-instances in the same cluster, it is the constraint entailment that brings them together. Those must-links could be found in the constraint pool which is recorded during the process of $\mathrm{COBRAS^{TS}}$. With those must-links, every pair of super-instances in a cluster could be connected. Another fact is that each sequence belongs to a super-instance, and the instances inside every super-instance have high similarity to each other. Based on the two facts above, we can connect two sequences in a cluster. We illustrate it together with an example in \cref{fig:entailment}.

In \cref{fig:entailment}, we have one cluster $ \mathcal{C}_1 $. In $ \mathcal{C}_1 $, we have three super-instances, $\mathit{S_1}$, $\mathit{S_2}$, and $\mathit{S_3}$ respectively. In $\mathit{S_1}$, there are four sequences, and the representative of $\mathit{S_1}$ is $\mathit{I_1}$. In $\mathit{S_2}$, there are three sequences, and the representative of $\mathit{S_2}$ is $\mathit{I_2}$. In $\mathit{S_3}$, there are five sequences, and the representative of $\mathit{S_3}$ is $\mathit{I_3}$. We are interested in why sequence $\mathit{a}$ and $\mathit{b}$ is in the same cluster $ \mathcal{C}_1 $.

Firstly, connect each sequence to the representative of the super-instance it belongs to. If the sequence itself is already the representative of the super-instance, skip this step. For instance in \cref{fig:entailment}, we would first find the representatives of the super-instances that $\mathit{a}$ and $\mathit{b}$ belong to. Sequence $\mathit{a}$ belongs to super-instance $\mathit{S_1}$, and the representative of $\mathit{S_1}$ is $\mathit{I_1}$, so we connect $\mathit{a}$ to $\mathit{I_1}$. Similarly, we also connect $\mathit{b}$ to $\mathit{I_3}$

Secondly, connect the representatives with the must-links in the constraint pool. In this example, we are trying to connect $\mathit{I_1}$ and $\mathit{I_3}$. We can see that there is a sequece $\mathit{I_2}$ which is the representative of super-instance $\mathit{S_2}$, and $\mathit{S_2}$ is also in the cluster $ \mathcal{C}_1 $. Besides, there is a must-link between $\mathit{I_1}$ and $\mathit{I_2}$, and there is also a must-link between $\mathit{I_2}$ and $\mathit{I_3}$. Therefore, we can connect $\mathit{I_1}$ and $\mathit{I_3}$ by first connecting $\mathit{I_1}$ and $\mathit{I_2}$ and then connecting $\mathit{I_2}$ and $\mathit{I_3}$. 

Finally, combing all the must-links selected above, we can connect $\mathit{a}$ and $\mathit{b}$ in a must-link chain $\mathit{a-I_1-I_2-I_3-b}$, which is shown as green dotted lines in \cref{fig:entailment}. 

\begin{figure}[htbp]	
	\centering
	\includegraphics[width=\linewidth]{pics/membership/entailment}
	\caption{why two sequences are in one cluster?}
	\label{fig:entailment}
\end{figure}
\subsection{Instances in two clusters}
\section{algorithm for readers to re-implement (pseudo code)}
\section{Experiments}
\subsection{Experiment on ECG dataset}
\subsection{Experiment on Trace dataset}
